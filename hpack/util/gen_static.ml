open Parsetree
open Ast_helper
open Asttypes

let let_ name body =
  (Str.value Nonrecursive
      [ Vb.mk (Pat.var {txt=name; loc = !default_loc}) body ])

module IntMap = Map.Make (struct
    type t = int
    let compare = compare
  end)

module StringMap = Map.Make (String)

module CharSet = Set.Make (Char)

let token_of_name =
  String.map @@ function
  | 'a' .. 'z' | 'A' .. 'Z' as c -> c
  | _ -> '_'

let mk_tokens static_table =
  let _, tokens = Array.fold_left (fun (prev_token, acc) (i, name, _) ->
    if name <> prev_token then
      let token =
        let_
          (Printf.sprintf "token_%s" (token_of_name name))
          (Exp.constant (Pconst_integer (string_of_int i, None)))
      in
      (name, token :: acc)
    else name, acc) ("", []) static_table
  in
  List.rev tokens

let add_name name i names =
  StringMap.update name begin function
  | Some i' -> Some (min i i')
  | None -> Some i
  end names

let find_pos names =
  let n = StringMap.cardinal names in
  let names = StringMap.bindings names |> List.map fst in
  let rec loop pos =
      if
        List.map (fun name -> name.[pos]) names
        |> CharSet.of_list
        |> CharSet.cardinal
        |> ( = ) n
      then pos else loop (pos + 1) in
  loop 0

let make_token_map static_table =
  Array.fold_left begin fun map (i, name, _) ->
    let length = String.length name in
    IntMap.update length begin function
    | Some names -> Some (add_name name i names)
    | None -> Some (StringMap.singleton name i)
    end map
  end IntMap.empty static_table
  |> IntMap.bindings
  |> List.map @@ fun (length, names) ->
  (length, find_pos names, StringMap.bindings names)

let mk_static_table static_table =
  let items = Array.fold_left (fun acc (_, name, value) ->
    let tup = Exp.tuple
      [ Exp.constant (Pconst_string (name, None))
      ; Exp.constant (Pconst_string (value, None)) ]
    in
    tup :: acc
  ) [] static_table
  in
  let_ "table" (Exp.array (List.rev items))

let mk_lookup_token token_map =
  let_ "lookup_token"
    (Exp.fun_
      Nolabel
      None
      (Pat.var {txt="name"; loc = !default_loc})
      (Exp.match_
        (Exp.apply
          (Exp.ident
            { txt = Longident.(Ldot (Lident "String", "length"))
            ; loc = !default_loc
            })
          [ Nolabel
          , Exp.ident
            { txt = Longident.Lident "name"
            ; loc = !default_loc
            }
          ])
        (List.concat
        [ List.map begin fun (length, pos, names) ->
            Exp.case
              (Pat.constant (Pconst_integer (string_of_int length, None)))
              (Exp.match_
                (Exp.apply
                  (Exp.ident
                      { txt = (Ldot (Lident "String", "get"))
                      ; loc = !default_loc
                      })
                  [ Nolabel
                  , Exp.ident
                    { txt = Lident "name"
                    ; loc = !default_loc
                    }
                  ; Nolabel
                  , Exp.constant (Pconst_integer (string_of_int pos, None))
                  ])
                (List.concat
                [ (List.map (fun (name, i) ->
                     Exp.case
                       (Pat.constant (Pconst_char name.[pos]))
                       ~guard:(Exp.apply
                                 (Exp.ident
                                     { txt = Lident "="
                                     ; loc = !default_loc
                                     })
                                [ Nolabel
                                , Exp.ident
                                  { txt = Lident "name"
                                  ; loc = !default_loc
                                  }
                                ; Nolabel
                                , Exp.constant (Pconst_string (name, None))
                                ])
                       (Exp.constant (Pconst_integer (string_of_int i, None))))
                  names)
                ; [ Exp.case
                    (Pat.any ())
                    (Exp.constant (Pconst_integer ("-1", None)))
                  ]
                ]))
          end token_map
        ; [ Exp.case
            (Pat.any ())
            (Exp.constant (Pconst_integer ("-1", None)))
          ]
        ])))

let () =
  let ic = open_in Sys.argv.(1) in
  let static_table = Array.init 61 @@ fun i ->
      let line = input_line ic in
      match String.split_on_char '\t' line with
      | [s; name] when int_of_string s == i + 1 -> (i, name, "")
      | [s; name; value] when int_of_string s == i + 1 -> (i, name, value)
      | _ -> assert false in
  let token_map = make_token_map static_table in
  let ppf = Format.std_formatter in
  Format.fprintf ppf "(* generated by util/gen_static.ml *)\n\n";
  let size = let_ "size" (Exp.constant (Pconst_integer ("61", None))) in
  Pprintast.structure ppf
    (List.concat
      [ size :: mk_tokens static_table
      ; [mk_static_table static_table]
      ; [mk_lookup_token token_map]
      ])
